#pragma once
#include <game_math.h>  // single include header for all glm math stuffs
#include <vector>

namespace phys
{
	/*
	 * Data needed to create a Node inside a `cSoftBody`
	 * Specifies starting position and mass
	 */
    struct sSoftBodyNodeDef
    {
        glm::vec3 Position;
        float Mass;
    };

	/*
	 * Data needed to create a `cSoftBody`.
	 * - A vector of `sSoftBodyNodeDef`s and
	 * - A vector of pairs of indices of the node vector
	 *   indicating the nodes connected by a spring
	 * - The stiffness constant of all the springs in the network
	 */
    struct sSoftBodyDef
    {
        std::vector<sSoftBodyNodeDef> Nodes;
        // The nodes of the cloth by index of the `nodes` vector
        std::vector<std::pair<size_t, size_t>> Springs;
        float SpringConstant;
    };
	
	/*
	 * Implementation of a network of "rigid bodies" that are attached
	 * to each other by flexible springs.
	 *
	 * The rigid bodies in the network can be moved by external forces
	 * (wind, gravity) or by other rigid bodies in the world.
	 *
	 * The springs will push or pull on the bodies they're attached to
	 * depending on the distance of the ends in relation to the length
	 * at rest of the spring and some "stiffness" constant.
	 */
    class cSoftBody
    {
    private:
        class cSpring;
    	/*
    	 * A body of the network connected by springs to another nodes.
    	 * TODO: Make them inherit from cRigidBody as a cSphere 
    	 */
		class cNode 
		{
            friend cSpring;
			friend cSoftBody;
            glm::vec3 SpringForce; // the force applied this frame by its springs
            glm::vec3 Position, Velocity, Acceleration;
            std::vector<cSpring*> AttachedSprings; // Springs attached to this node
            float Radius, Mass;
		public:
            virtual ~cNode() = default;
            cNode(const sSoftBodyNodeDef& def);
			/*
			 * Is a node attached to this one by a spring?
			 * other: another node to check if I'm attached to
			 * return: if I'm attached or not
			 */
            bool IsNeighbor(cNode* other);
			/*
			 * Calculate the radius of the node depending on the distance
			 * at rest to its neighbors
			 */
            void CalculateRadius();
		};

    	/*
    	 * Connection between two `cNode`s in the network.
    	 *
    	 * It's able to apply forces to those nodes in relation
    	 * to the distance of the nodes against the length of the
    	 * spring at rest and the stiffness constant.
    	 */
    	class cSpring
    	{
            friend cNode;
            friend cSoftBody;
            cNode* NodeA, * NodeB;
            float RestingLength;
            float StiffnessConstant;
            glm::vec3 CurrentForceAtoB;
    	public:
            cSpring(cNode* nodeA, cNode* nodeB, float springConstant);
            virtual ~cSpring() = default;
    		/*
    		 * If `node` is at one of the ends of the spring,
    		 * return the other node.
    		 * `node`: The opposite node of the one we'll return
    		 * return: The opposite node of `node`. nullptr if `node`
    		 * is not part of this string
    		 */
            cNode* getOther(cNode* node);
    		/*
    		 * Recalculate `CurrentForceAtoB` according to the current
    		 * positions of the nodes in world space.
    		 */
            void UpdateSpringForce();
    		/*
    		 * Apply the force generated by the spring to the nodes at
    		 * the end of it.
    		 */
            void ApplyForceToNodes();
    	};
        std::vector<cNode*> mNodes;
        std::vector<cSpring*> mSprings;
    protected:
    	/*
    	 * Calculate all of the forces of all the springs attached to
    	 * `node` and apply them to the node
    	 */
        void IntegrateNode(cNode *node);
    public:
        cSoftBody(sSoftBodyDef& def);
    	virtual ~cSoftBody();
    	/*
    	 * Get the opposite ends of the axis aligned bounding box
    	 * containing all of the nodes in the mesh
         * `mins`: will contain the corner with the lowest coordinates
         * `maxs`: will contain the corner with the highest coordinates
         * return: if the operation could be realized succesfully.
    	 */
        bool GetAABB(glm::vec3& mins, glm::vec3& maxs);
    	/*
    	 * Get the position of a certain node of the mesh by index
    	 * `index`: the position of the desired node in the vector
    	 * `positionOut` (return): The position of the node
    	 * return: If `index` is inside the bounds of the node vector
    	 */
        bool GetNodePosition(size_t index, glm::vec3& positionOut);
        /*
         * Get the radius of a certain node of the mesh by index
         * `index`: the position of the desired node in the vector
         * `radiusOut` (return): The radius of the node
         * return: If `index` is inside the bounds of the node vector
         */
        bool GetNodeRadius(size_t index, float& radiusOut);
    	/*
    	 * The amount of nodes the mesh has
    	 */
        size_t numNodes();
        void Integrate(float deltaTime);
        void updateInternal(float dt, const glm::vec3& gravity, const glm::vec3& wind);
    };
}

