#pragma once
#include <game_math.h>  // single include header for all glm math stuffs
#include <vector>
#include "iCollisionBody.h"
#include "cIntegrator.h"

namespace phys
{
	/*
	 * Data needed to create a Node inside a `cSoftBody`
	 * Specifies starting position and mass
	 */
    struct sSoftBodyNodeDef
    {
        glm::vec3 Position;
        float Mass;
    };

	/*
	 * Data needed to create a `cSoftBody`.
	 * - A vector of `sSoftBodyNodeDef`s and
	 * - A vector of pairs of indices of the node vector
	 *   indicating the nodes connected by a spring
	 * - The stiffness constant of all the springs in the network
	 */
    struct sSoftBodyDef
    {
        std::vector<sSoftBodyNodeDef> Nodes;
        // The nodes of the cloth by index of the `nodes` vector
        std::vector<std::pair<size_t, size_t>> Springs;
        float SpringConstant;
    };
	
	/*
	 * Implementation of a network of "rigid bodies" that are attached
	 * to each other by flexible springs.
	 *
	 * The rigid bodies in the network can be moved by external forces
	 * (wind, gravity) or by other rigid bodies in the world.
	 *
	 * The springs will push or pull on the bodies they're attached to
	 * depending on the distance of the ends in relation to the length
	 * at rest of the spring and some "stiffness" constant.
	 */
    struct cSoftBody : public iCollisionBody
    {
        class cSpring;
    	/*
    	 * A body of the network connected by springs to another nodes.
    	 */
		struct cNode 
		{
            friend cSpring;
			friend cSoftBody;
            glm::vec3 mSpringForce; // the force applied this frame by its springs
            std::vector<cSpring*> mAttachedSprings; // Springs attached to this node
            float mRadius, mMass;
            glm::vec3 mPosition, mVelocity, mAcceleration, mPreviousPosition;
            virtual ~cNode() = default;
            cNode(const sSoftBodyNodeDef& def);
			/*
			 * Is a node attached to this one by a spring?
			 * other: another node to check if I'm attached to
			 * return: if I'm attached or not
			 */
            bool IsNeighbor(cNode* other);
			/*
			 * Calculate the radius of the node depending on the distance
			 * at rest to its neighbors
			 */
            void CalculateRadius();
			/*
			 * Applies a force to this node considering his mass
			 */
            void ApplyForce(const glm::vec3 &force);
            /*
             * Simulates the movement and acceleration of the node
             * for a single "time step" of length `deltaTime`.
             * Applies `externalForces` to the acceleration
             */
            void Integrate(
                float deltaTime, 
                const glm::vec3& externalForces = glm::vec3(0));
		};

    	/*
    	 * Connection between two `cNode`s in the network.
    	 *
    	 * It's able to apply forces to those nodes in relation
    	 * to the distance of the nodes against the length of the
    	 * spring at rest and the stiffness constant.
    	 */
    	struct cSpring
    	{
            friend cNode;
            friend cSoftBody;
            float mRestingLength;
            float mStiffnessConstant;
            glm::vec3 mCurrentForceAtoB;
            cNode* mNodeA, * mNodeB;
            cSpring(cNode* nodeA, cNode* nodeB, float springConstant);
            virtual ~cSpring() = default;
    		/*
    		 * If `node` is at one of the ends of the spring,
    		 * return the other node.
    		 * `node`: The opposite node of the one we'll return
    		 * return: The opposite node of `node`. nullptr if `node`
    		 * is not part of this string
    		 */
            cNode* getOther(cNode* node);
    		/*
    		 * Recalculate `CurrentForceAtoB` according to the current
    		 * positions of the nodes in world space.
    		 */
            void UpdateSpringForce();
    		/*
    		 * Apply the force generated by the spring to the nodes at
    		 * the end of it.
    		 */
            void ApplyForceToNodes();
    	};
        std::vector<cNode*> mNodes;
        cIntegrator mIntegrator;
        std::vector<cSpring*> mSprings;
        cSoftBody(sSoftBodyDef& def);
    	virtual ~cSoftBody();
    	/*
    	 * Generates a string detailing info about the soft body
    	 */
        std::string toString();
    	/*
    	 * Get the opposite ends of the axis aligned bounding box
    	 * containing all of the nodes in the mesh
         * `mins`: will contain the corner with the lowest coordinates
         * `maxs`: will contain the corner with the highest coordinates
         * return: if the operation could be realized succesfully.
    	 */
        bool GetAABB(glm::vec3& mins, glm::vec3& maxs);
    	/*
    	 * Get the position of a certain node of the mesh by index
    	 * `index`: the position of the desired node in the vector
    	 * `positionOut` (return): The position of the node
    	 * return: If `index` is inside the bounds of the node vector
    	 */
        bool GetNodePosition(size_t index, glm::vec3& positionOut);
        /*
         * Get the radius of a certain node of the mesh by index
         * `index`: the position of the desired node in the vector
         * `radiusOut` (return): The radius of the node
         * return: If `index` is inside the bounds of the node vector
         */
        bool GetNodeRadius(size_t index, float& radiusOut);
    	/*
    	 * The amount of nodes the mesh has
    	 */
        size_t numNodes();
        void Integrate(
            float deltaTime, 
            const glm::vec3& gravity = glm::vec3(0), 
            const glm::vec3& wind = glm::vec3(0));
        void updateInternal(
            float dt, 
            const glm::vec3& gravity = glm::vec3(0),
            const glm::vec3& wind = glm::vec3(0));
    	/*
    	 * Sets the accelerations of all of the nodes to 0 in all axis
    	 */
        virtual void ClearAccelerations();
    };
}

